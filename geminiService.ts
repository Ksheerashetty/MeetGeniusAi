
import { GoogleGenAI, Type } from "@google/genai";
import { OrchestrationData } from "./types";

const SYSTEM_PROMPT = `You are the "MeetGenius Orchestrator," an enterprise-grade AI specialized in converting meeting transcripts into structured, actionable outcomes.

YOUR CORE MISSION:
1. Summarize the meeting concisely.
2. Identify all key decisions made.
3. Extract all action items and assign them to the correct owners.
4. Generate INDIVIDUAL, EXECUTABLE email payloads for every participant.

EMAIL PAYLOAD RULES:
- Recipient ("to"): Identify the participant's email. If not explicit, infer based on name (e.g., name@company.com). 
- Subject: "Action Items: [Meeting Title] - [Date]"
- Body: Professional HTML content using these exact sections:
    - Greeting: "Hi [Name],"
    - Summary Section: "<h3>üìù Executive Summary</h3>" followed by the summary.
    - Personal Tasks: "<h3>‚úÖ Your Action Items</h3>". List ONLY tasks assigned to THIS person. If none, state "No specific action items assigned."
    - Global Decisions: "<h3>üìå Key Decisions</h3>" listing all meeting decisions.
    - Footer: "Generated by MeetGenius AI Intelligence Engine."

ENFORCEMENT:
- Sender: Must use the provided logged_in_user_email as the sender in the intent.
- Formatting: Ensure HTML in the email body is valid and well-structured.
- Logic: Skip participants if you cannot determine a name or identity.

STRICT TRANSCRIPTION RULES:
- If the transcript is missing or contains only garbage/placeholders, you MUST set blocking_error.is_blocking to true and provide a clear reason.
- Never hallucinate tasks or owners.`;

const RESPONSE_SCHEMA = {
  type: Type.OBJECT,
  properties: {
    auth_fix: {
      type: Type.OBJECT,
      properties: {
        signin_required: { type: Type.BOOLEAN },
        email_captured: { type: Type.BOOLEAN },
        auth_provider: { type: Type.STRING, nullable: true },
        blocking_reason: { type: Type.STRING, nullable: true }
      },
      required: ["signin_required", "email_captured"]
    },
    audio_pipeline_status: {
      type: Type.OBJECT,
      properties: {
        input_received: { type: Type.BOOLEAN },
        file_type: { type: Type.STRING, nullable: true },
        audio_validated: { type: Type.BOOLEAN },
        audio_extracted: { type: Type.BOOLEAN },
        transcription_triggered: { type: Type.BOOLEAN },
        transcription_completed: { type: Type.BOOLEAN },
        transcript_available: { type: Type.BOOLEAN }
      },
      required: ["input_received", "audio_validated", "transcription_triggered", "transcription_completed", "transcript_available"]
    },
    transcription_diagnostic: {
      type: Type.OBJECT,
      properties: {
        diagnosis: {
          type: Type.OBJECT,
          properties: {
            audio_access_ok: { type: Type.BOOLEAN },
            format_supported: { type: Type.BOOLEAN },
            audio_extracted: { type: Type.BOOLEAN },
            transcription_called: { type: Type.BOOLEAN },
            transcription_response_valid: { type: Type.BOOLEAN }
          },
          required: ["audio_access_ok", "format_supported", "audio_extracted", "transcription_called", "transcription_response_valid"]
        },
        failure_point: { type: Type.STRING, nullable: true },
        root_cause: { type: Type.STRING, nullable: true },
        required_fix: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              step: { type: Type.STRING },
              action: { type: Type.STRING }
            },
            required: ["step", "action"]
          }
        },
        transcript_status: {
          type: Type.OBJECT,
          properties: {
            available: { type: Type.BOOLEAN },
            length: { type: Type.NUMBER }
          },
          required: ["available", "length"]
        },
        pipeline_state: { type: Type.STRING }
      },
      required: ["diagnosis", "required_fix", "transcript_status", "pipeline_state"]
    },
    transcript_preview: { type: Type.STRING, nullable: true },
    blocking_error: {
      type: Type.OBJECT,
      properties: {
        is_blocking: { type: Type.BOOLEAN },
        reason: { type: Type.STRING, nullable: true }
      },
      required: ["is_blocking"]
    },
    next_allowed_step: { type: Type.STRING },
    outlook_fix: {
      type: Type.OBJECT,
      properties: {
        outlook_ready: { type: Type.BOOLEAN },
        missing_prerequisites: { type: Type.ARRAY, items: { type: Type.STRING } },
        calendar_execution_ready: { type: Type.BOOLEAN },
        email_execution_ready: { type: Type.BOOLEAN }
      },
      required: ["outlook_ready", "missing_prerequisites", "calendar_execution_ready", "email_execution_ready"]
    },
    email_execution_intent: {
      type: Type.OBJECT,
      properties: {
        intent: { type: Type.STRING },
        sender: {
          type: Type.OBJECT,
          properties: {
            email: { type: Type.STRING },
            auth_provider: { type: Type.STRING }
          },
          required: ["email", "auth_provider"]
        },
        emails: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              to: { type: Type.STRING },
              subject: { type: Type.STRING },
              body: {
                type: Type.OBJECT,
                properties: {
                  contentType: { type: Type.STRING },
                  content: { type: Type.STRING }
                },
                required: ["contentType", "content"]
              }
            },
            required: ["to", "subject", "body"]
          }
        },
        blocking_error: {
          type: Type.OBJECT,
          properties: {
            is_blocking: { type: Type.BOOLEAN },
            reason: { type: Type.STRING, nullable: true }
          },
          required: ["is_blocking"]
        }
      },
      required: ["intent", "sender", "emails", "blocking_error"]
    },
    next_actions: { type: Type.ARRAY, items: { type: Type.STRING } },
    shared_meeting_template: {
      type: Type.OBJECT,
      nullable: true,
      properties: {
        summary: { type: Type.STRING },
        agenda_items: { type: Type.ARRAY, items: { type: Type.STRING } },
        key_discussions: { type: Type.ARRAY, items: { type: Type.STRING } },
        decisions: { type: Type.ARRAY, items: { type: Type.STRING } },
        action_items: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              task: { type: Type.STRING },
              owner: { type: Type.STRING, nullable: true },
              deadline: { type: Type.STRING, nullable: true },
              confidence_score: { type: Type.NUMBER }
            },
            required: ["task", "confidence_score"]
          }
        }
      }
    },
    meeting_metadata: {
      type: Type.OBJECT,
      properties: {
        meeting_title: { type: Type.STRING, nullable: true },
        meeting_date: { type: Type.STRING, nullable: true },
        attendees: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              name: { type: Type.STRING },
              email: { type: Type.STRING, nullable: true }
            },
            required: ["name"]
          }
        }
      },
      required: ["attendees"]
    }
  },
  required: ["auth_fix", "audio_pipeline_status", "blocking_error", "next_allowed_step", "outlook_fix", "email_execution_intent", "next_actions", "meeting_metadata"]
};

export const runCorrectiveOrchestration = async (
  input: string,
  userEmail: string | null,
  authProvider: string | null,
  isAudio: boolean
): Promise<OrchestrationData> => {
  const ai = new GoogleGenAI({ apiKey: import.meta.env.VITE_GEMINI_API_KEY });
  try {
    const prompt = `
      LOGGED-IN USER (SENDER): ${userEmail || "MISSING"}
      AUTH PROVIDER: ${authProvider || "NONE"}
      
      MEETING DATA:
      ${input}
      
      ORCHESTRATOR REQUEST:
      Identify the meeting title, date, and participants.
      Extract summary, decisions, and action items.
      Generate individual HTML email payloads for EVERY participant.
      Each email must list ONLY that participant's tasks in the action items section.
      Redirect all generated emails to ksheerashetty@gmail.com for testing if you are unsure of the attendee's email, otherwise use your best inference for professional placeholders.
    `;

    const response = await ai.models.generateContent({
      model: "gemini-3-flash-preview",
      contents: [{ parts: [{ text: prompt }] }],
      config: {
        systemInstruction: SYSTEM_PROMPT,
        responseMimeType: "application/json",
        responseSchema: RESPONSE_SCHEMA,
      },
    });

    const text = response.text;
    if (!text) throw new Error("MeetGenius Orchestrator encountered an empty response.");

    return JSON.parse(text) as OrchestrationData;
  } catch (error) {
    console.error("Gemini Orchestration Error:", error);
    throw error;
  }
};
